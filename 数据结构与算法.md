# study-note
### 树
#### 二叉树
##### 定义及基本术语
根，左右子树，空树，结点（根结点，分支结点，叶子结点），结点度数(0,1,2)。</br>
二叉树具有五种基本形态：a）空二叉树；b）只有根节点；c）根节点只有非空左子树；d）根节点只有非空右子树；e）根节点有非空的左右子树。  
层数，深度（自顶向下），高度（自底向上）。  
满二叉树，完全二叉树（n个结点与满二叉树前n个结点一一对应）。  
完全二叉树度为 1 的结点数要么为 0 要么为 1。  
##### 基本属性
1.第i层最多2<sup>i-1</sup>个结点。  
2.深度为k，最多2<sup>k</sup>-1个结点。  
3.度为0节点数n<sub>0</sub>，n<sub>0</sub>=n<sub>2</sub>+1。  
4.n个结点的完全二叉树，深度为log<sub>2</sub>n下取整+1。  
5.对于完全二叉树，n个结点并以根节点为1开始编号，对于任意结点i，2i为其左结点，2i+1为其右结点（若大于n则为空）。  
##### 存储结构
顺序存储结构（完全二叉树较为适合），链式存储结构。  
##### 遍历
三种顺序：先序，中序，后序。递归实现，非递归实现（入栈）。  
已知两种遍历序列可以确定二叉树？除了先序+后序，其他可以。
遍历的应用：构建二叉树链表，求树的深度，复制二叉树，求算数表达式的值。  
线索二叉树：加入前驱、后序指针。  
##### 二叉排序树
空树，或者满足左小右大（或等于）。因此其中序遍历为有序序列。  
排序过程是从空树起不断插入结点的过程，稳定排序。
##### 哈夫曼树（最优树）
二叉树时，带权路径长度最小的树。当n=1时，n<sub>1</sub>=1;否则为0。  
应用：判定树（构造最优二叉树）提高效率；通信、编码（前缀编码）、压缩。  
哈夫曼码（前缀编码）：构造哈夫曼树，左0右1进行编码。  

### 顺序表和链表  
##### 顺序表  
需要预分配存储空间，位序可以随机访问，插入删除需要大量移动元素。  
##### 链表
动态分配内存，需要遍历来访问某个元素，插入删除方便。  
### 排序
##### 基本概念
稳定性：关键字相等的两个记录，排序后的顺序是否唯一。  
内部排序，外部排序。（涉及的存储器）  
内部排序的过程是一个逐步扩大记录的有序序列长度的过程。  
##### 选择排序
R[1~i-1]有序，每次选取无序区**最小**的元素R[j]，与无序区的第一个元素R[i]交换。  
时间复杂度O（n<sup>2</sup>）,不稳定排序。（交换的策略导致了不稳定，可以改为稳定）  
![选择排序](https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)
[维基百科-选择排序](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)   
##### 插入排序
将无序区的R[i]，插入到有序区R[1~i-1]中，使有序区长度+1。插入过程**从后往前**搜索并插入。（因此**已有序**时O(n)）  
时间复杂度O（n<sup>2</sup>）,稳定排序。  
![插入排序](https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif)   
[维基百科-插入排序](https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)  
##### 冒泡排序
将无序区的记录进行**相邻**记录的比较和交换，使得较小记录移动到一边，较大记录移动到另一边。  
时间复杂度O（n<sup>2</sup>）,稳定排序。  
![冒泡排序](https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif)   
[维基百科-冒泡排序](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)  
##### 快速排序
通过一趟排序将待排记录分割成两个区域A、B，A<B，再将A、B进行排序。  
时间复杂度O(nlogn)，但当序列有序时退化为冒泡排序O(n<sup>2</sup>)，不稳定排序。</br>
![快速排序](http://img.my.csdn.net/uploads/201205/07/1336347520_8718.png) </br>
##### 归并排序
将两个位置相邻的有序子序列归并为一个有序序列。  
时间复杂度O(nlogn)，空间复杂度O(n)，稳定排序。  
![归并排序](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)    
[维基百科-归并排序](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)  
##### 堆排序
近似完全二叉树，且满足堆的性质：子结点的键值总小于(大于)父结点。</br>
每次输出堆顶元素，并用最后一个元素将其替代，然后进行自顶向下进行堆调整。因为做右子树都满足堆的特性，因此调整时间复杂度为O(logn)。</br>
时间复杂度O(nlogn)，空间复杂度O(1)，不稳定排序。</br>
##### 基数排序
对关键字进行**分配**和**收集**，将逻辑关键字看出多个(d个)关键字的复合。  
对于整数，实现方法：将数值统一数位长度，从最低位开始到最高位进行排序，从而变成有序序列。  
时间复杂度O(d * n)，空间复杂度O(n)，稳定排序。  
##### 希尔排序
也称**递减增量排序算法**，插入排序的一种改进。插入排序对有序序列是O(n)。  
将待排序列**分割**为若干子序列分别进行插入排序，从而基本有序后，整体进行插入排序。    
时间复杂度大于O(nlogn)，空间复杂度O(1)，不稳定排序。   
##### 桶排序
将记录分到有限数量的k个桶里。每个桶再个别排序。    
时间复杂度O(n+k),空间复杂度O(n * k)，稳定排序。   
![排序总结](http://img.my.csdn.net/uploads/201207/19/1342700879_2982.jpg)   
### 栈和队列
栈和队列是两种**线性数据结构**，栈是后进先出，队列是先进先出。   
##### 栈
只允许在一端插入和删除的线性表。存储表示方法有顺序栈、链栈。    
出栈的可能序列个数遵循卡特兰数：![卡特兰数](https://wikimedia.org/api/rest_v1/media/math/render/svg/57de4926a69e67cdcdf999030c5ec3c25d97b0c9)</br>
栈的应用：数制转换、括号匹配、背包问题、后缀表达式、递归算法、求回文等。   
消除递归不一定需要使用栈，因为对于**尾递归**可以不设置栈，而直接通过改变过程中的参数值，利用循环结构代替递归调用。   
堆和栈的区别：   
1.内存分配中：   
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。   
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</br>
2.缓存方式：   
栈：一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</br>
堆：二级缓存，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</br>
3.数据结构中区别：</br>
堆（数据结构）：堆可以被看成是一棵树，如：堆排序。</br>
栈（数据结构）：一种先进后出的数据结构。</br>
##### 队列
循环队列，约定尾指针指向队尾元素的下一个元素。</br>队满条件为 (rear+1)%m == front; 队空条件为 rear == front；队列元素个数为(rear-front+m)%m。</br>
队列的应用：杨辉三角，划分无冲突子集(安排日程)等</br>
### 字符串和数组
##### 字符串
字符串匹配：朴素算法，RK算法(将匹配字段转换为数值，取模比较)，有限自动机算法(状态转移函数，判断当前后缀与模式最大前缀相等的长度)，KMP算法(使用前缀函数代替自动机算法的转移函数，查找当前位置后缀能匹配的最长前缀，达到O(m)的时间复杂度)。</br>利用数组查找最长公共子串。</br>
